(** val manifest_generator_plcTerm_list :
    (coq_Term * coq_Plc) list -> coq_EnvironmentM list **)

fun manifest_generator_plcTerm_list ls =
  map (fn pat => let val (t, p) = pat in manifest_generator t p end) ls

(** val env_list_union : coq_EnvironmentM list -> coq_EnvironmentM **)

fun env_list_union ls =
  fold_right environment_union e_empty ls

(** val mangen_plcTerm_list_union :
    (coq_Term * coq_Plc) list -> coq_EnvironmentM **)

fun mangen_plcTerm_list_union ls =
  env_list_union (manifest_generator_plcTerm_list ls)

(** val manifest_generator_plcEvidence_list :
    (coq_Evidence * coq_Plc) list -> coq_EnvironmentM list **)

fun manifest_generator_plcEvidence_list ls =
  map (fn pat => let val (et, p) = pat in manifest_generator_app et p end) ls

(** val mangen_plcEvidence_list_union :
    (coq_Evidence * coq_Plc) list -> coq_EnvironmentM **)

fun mangen_plcEvidence_list_union ls =
  env_list_union (manifest_generator_plcEvidence_list ls)

type coq_Evidence_Plc_list = (coq_Evidence * coq_Plc) list

(** val coq_Evidence_Plc_list_to_JSON :
    coq_Evidence coq_Jsonifiable -> coq_Evidence_Plc_list -> coq_JSON **)

fun coq_Evidence_Plc_list_to_JSON h ls =
  JSON_Object (("Evidence_Plc_list", (InJSON_Array
    (map (fn pat =>
      let val (et, p) = pat in
      InJSON_Array ((InJSON_Object
      (let val Build_Jsonifiable to_JSON _ = h in to_JSON et end)) :: ((InJSON_String
      (let val Build_Stringifiable to_string _ = coq_Stringifiable_ID_Type in
       to_string p end)) :: [])) end) ls))) :: [])

(** val coq_Evidence_Plc_list_from_JSON :
    coq_Evidence coq_Jsonifiable -> coq_JSON -> (coq_Evidence_Plc_list,
    string) coq_ResultT **)

fun coq_Evidence_Plc_list_from_JSON h js =
  case coq_JSON_get_Array "Evidence_Plc_list" js of
    Coq_errC e => Coq_errC e
  | Coq_resultC jsArr =>
    result_map (fn js0 =>
      case js0 of
        InJSON_Object _ => Coq_errC "Not a pair"
      | InJSON_Array l =>
        (case l of
           [] => Coq_errC "Not a pair"
         | i :: l0 =>
           (case i of
              InJSON_Object jsEt =>
              (case l0 of
                 [] => Coq_errC "Not a pair"
               | i0 :: l1 =>
                 (case i0 of
                    InJSON_Object _ => Coq_errC "Not a pair"
                  | InJSON_Array _ => Coq_errC "Not a pair"
                  | InJSON_String jsP =>
                    (case l1 of
                       [] =>
                       (case let val Build_Jsonifiable _ from_JSON = h in
                             from_JSON jsEt end of
                          Coq_errC _ =>
                          Coq_errC "Error in parsing Evidence_Plc_list"
                        | Coq_resultC et =>
                          (case let val Build_Stringifiable _ from_string =
                                  coq_Stringifiable_ID_Type
                                in
                                from_string jsP end of
                             Coq_errC _ =>
                             Coq_errC "Error in parsing Evidence_Plc_list"
                           | Coq_resultC p => Coq_resultC (et, p)))
                     | _ :: _ => Coq_errC "Not a pair")
                  | InJSON_Boolean _ => Coq_errC "Not a pair"))
            | _ => Coq_errC "Not a pair"))
      | _ => Coq_errC "Not a pair") jsArr

(** val coq_Jsonifiable_Evidence_Plc_list :
    coq_Evidence coq_Jsonifiable -> coq_Evidence_Plc_list coq_Jsonifiable **)

fun coq_Jsonifiable_Evidence_Plc_list h =
  Build_Jsonifiable (coq_Evidence_Plc_list_to_JSON h)
    (coq_Evidence_Plc_list_from_JSON h)

type coq_Term_Plc_list = (coq_Term * coq_Plc) list

(** val coq_Term_Plc_list_to_JSON :
    coq_Term coq_Jsonifiable -> coq_Term_Plc_list -> coq_JSON **)

fun coq_Term_Plc_list_to_JSON h ls =
  JSON_Object (("Term_Plc_list", (InJSON_Array
    (map (fn pat =>
      let val (et, p) = pat in
      InJSON_Array ((InJSON_Object
      (let val Build_Jsonifiable to_JSON _ = h in to_JSON et end)) :: ((InJSON_String
      (let val Build_Stringifiable to_string _ = coq_Stringifiable_ID_Type in
       to_string p end)) :: [])) end) ls))) :: [])

(** val coq_Term_Plc_list_from_JSON :
    coq_Term coq_Jsonifiable -> coq_JSON -> (coq_Term_Plc_list, string)
    coq_ResultT **)

fun coq_Term_Plc_list_from_JSON h js =
  case coq_JSON_get_Array "Term_Plc_list" js of
    Coq_errC e => Coq_errC e
  | Coq_resultC jsArr =>
    result_map (fn js0 =>
      case js0 of
        InJSON_Object _ => Coq_errC "Not a pair"
      | InJSON_Array l =>
        (case l of
           [] => Coq_errC "Not a pair"
         | i :: l0 =>
           (case i of
              InJSON_Object jsTerm =>
              (case l0 of
                 [] => Coq_errC "Not a pair"
               | i0 :: l1 =>
                 (case i0 of
                    InJSON_Object _ => Coq_errC "Not a pair"
                  | InJSON_Array _ => Coq_errC "Not a pair"
                  | InJSON_String jsP =>
                    (case l1 of
                       [] =>
                       (case let val Build_Jsonifiable _ from_JSON = h in
                             from_JSON jsTerm end of
                          Coq_errC _ =>
                          Coq_errC "Error in parsing Term_Plc_list"
                        | Coq_resultC et =>
                          (case let val Build_Stringifiable _ from_string =
                                  coq_Stringifiable_ID_Type
                                in
                                from_string jsP end of
                             Coq_errC _ =>
                             Coq_errC "Error in parsing Term_Plc_list"
                           | Coq_resultC p => Coq_resultC (et, p)))
                     | _ :: _ => Coq_errC "Not a pair")
                  | InJSON_Boolean _ => Coq_errC "Not a pair"))
            | _ => Coq_errC "Not a pair"))
      | _ => Coq_errC "Not a pair") jsArr

(** val coq_Jsonifiable_Term_Plc_list :
    coq_Term coq_Jsonifiable -> coq_Term_Plc_list coq_Jsonifiable **)

fun coq_Jsonifiable_Term_Plc_list h =
  Build_Jsonifiable (coq_Term_Plc_list_to_JSON h)
    (coq_Term_Plc_list_from_JSON h)

(** val knowsof_myPlc_manifest_update_env' :
    (coq_Plc * coq_Manifest) -> coq_Plc * coq_Manifest **)

fun knowsof_myPlc_manifest_update_env' p =
  ((fst p), (knowsof_myPlc_manifest_update (snd p)))

(** val update_knowsOf_myPlc_env : coq_EnvironmentM -> coq_EnvironmentM **)

fun update_knowsOf_myPlc_env env =
  map knowsof_myPlc_manifest_update_env' env

(** val update_pubkeys_env' :
    coq_Plc manifest_set -> (coq_Plc * coq_Manifest) -> coq_Plc * coq_Manifest **)

fun update_pubkeys_env' pubs p =
  ((fst p), (pubkeys_manifest_update pubs (snd p)))

(** val update_pubkeys_env :
    coq_Plc manifest_set -> coq_EnvironmentM -> coq_EnvironmentM **)

fun update_pubkeys_env pubs env =
  map (update_pubkeys_env' pubs) env

(** val end_to_end_mangen' :
    coq_Evidence_Plc_list -> coq_Term_Plc_list -> coq_EnvironmentM **)

fun end_to_end_mangen' ls ts =
  let val app_env = mangen_plcEvidence_list_union ls in
  let val att_env = mangen_plcTerm_list_union ts in
  environment_union app_env att_env end end

(** val manset_union_list :
    'a1 coq_EqClass -> 'a1 manifest_set manifest_set -> 'a1 manifest_set **)

fun manset_union_list hA lss =
  fold_right (manset_union hA) [] lss

(** val get_all_unique_places :
    coq_Term_Plc_list -> coq_Evidence_Plc_list -> coq_Plc manifest_set **)

fun get_all_unique_places ls ets =
  let val lss =
    map (fn pat => let val (t, p) = pat in places_manset p t end) ls
  in
  let val ts_ps = manset_union_list coq_Eq_Class_ID_Type lss in
  let val ets_ps = map (fn pat => let val (_, p) = pat in p end) ets in
  manset_union coq_Eq_Class_ID_Type ts_ps ets_ps end end end

(** val end_to_end_mangen :
    coq_Evidence_Plc_list -> coq_Term_Plc_list -> coq_EnvironmentM **)

fun end_to_end_mangen ls ts =
  let val ps = get_all_unique_places ts ls in
  update_pubkeys_env ps (update_knowsOf_myPlc_env (end_to_end_mangen' ls ts)) end

(** val end_to_end_mangen_final :
    coq_Evidence_Plc_list -> coq_Term_Plc_list -> coq_Manifest list **)

fun end_to_end_mangen_final ls ts =
  environment_to_manifest_list (end_to_end_mangen ls ts)
