(** val gen_nonce_if_none : coq_EvC option -> coq_EvC coq_AM **)

fun gen_nonce_if_none initEv = case initEv of
  Some e => ret e
| None =>
  bind (am_newNonce gen_nonce_bits) (fn nid =>
    ret (Coq_evc (gen_nonce_bits :: []) (Coq_nn nid)))

(** val gen_authEvC_if_some : coq_Term option -> coq_Plc -> coq_EvC coq_AM **)

fun gen_authEvC_if_some ot pFrom =
  case ot of
    Some auth_phrase =>
    let val auth_rawev = run_cvm_rawEv auth_phrase pFrom [] in
    let val auth_et = eval auth_phrase pFrom Coq_mt in
    ret (Coq_evc auth_rawev auth_et) end end
  | None => ret (Coq_evc [] Coq_mt)

(** val am_sendReq_gen :
    coq_Term -> coq_Plc -> coq_Plc -> coq_EvC option -> coq_Term option ->
    coq_CakeML_PlcCallback -> bool -> coq_AM_Result coq_AM **)

fun am_sendReq_gen t pFrom pTo initEv authPhrase plcCb app_bool =
  bind (gen_nonce_if_none initEv) (fn evcIn =>
    bind (gen_authEvC_if_some authPhrase pFrom) (fn auth_evc =>
      let val Coq_evc init_ev init_et = evcIn in
      let val targetUUID = plcCb pTo in
      let val resev = am_sendReq t targetUUID auth_evc init_ev in
      (case app_bool of
         True =>
         let val expected_et = eval t pTo init_et in
         bind (gen_appraise_AM expected_et resev) (fn app_res =>
           ret (Coq_am_appev app_res)) end
       | False => ret (Coq_am_rawev resev)) end end end))

(** val am_sendReq_dispatch :
    coq_Term option -> bool -> coq_Term -> coq_Plc -> coq_Plc -> bool ->
    coq_CakeML_PlcCallback -> coq_AM_Result coq_AM **)

fun am_sendReq_dispatch maybeAuthTerm nonceB t source dest app_bool plcCb =
  let val nonce_param =
    case nonceB of
      True => None
    | False => Some (Coq_evc [] Coq_mt)
  in
  am_sendReq_gen t source dest nonce_param maybeAuthTerm plcCb app_bool end
