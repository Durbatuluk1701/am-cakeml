(** val peel_bs_am : coq_RawEv -> (coq_BS, coq_RawEv) prod coq_AM **)

fun peel_bs_am ls = case ls of
  [] => failm
| bs :: ls' => ret (Coq_pair bs ls')

(** val gen_appraise_AM :
    coq_Evidence -> coq_RawEv -> coq_AppResultC coq_AM **)

fun gen_appraise_AM et ls =
  case et of
    Coq_mt => ret Coq_mtc_app
  | Coq_nn nid =>
    bind (peel_bs_am ls) (fn v =>
      let val Coq_pair bs _ = v in
      bind (checkNonce' nid bs) (fn res => ret (Coq_nnc_app nid res)) end)
  | Coq_uu p fwd params et' =>
    (case fwd of
       ENCR =>
       bind (peel_bs_am ls) (fn v =>
         let val Coq_pair bs _ = v in
         bind (decrypt_bs_to_rawev' bs params) (fn decrypted_ls =>
           bind (gen_appraise_AM et' decrypted_ls) (fn rest =>
             ret (Coq_eec_app p params passed_bs rest))) end)
     | EXTD =>
       bind (peel_bs_am ls) (fn v =>
         let val Coq_pair bs ls' = v in
         bind (check_asp_EXTD' params p bs ls') (fn v0 =>
           bind (gen_appraise_AM et' ls') (fn rest =>
             ret (Coq_ggc_app p params v0 rest))) end)
     | KEEP => gen_appraise_AM et' ls
     | _ => ret Coq_mtc_app)
  | Coq_ss et1 et2 =>
    bind (gen_appraise_AM et1 (firstn (et_size et1) ls)) (fn x =>
      bind (gen_appraise_AM et2 (skipn (et_size et1) ls)) (fn y =>
        ret (Coq_ssc_app x y)))

(** val fromSome : 'a1 -> 'a1 option -> 'a1 **)

fun fromSome default opt = case opt of
  Some x => x
| None => default

(** val run_am_app_comp : 'a1 coq_AM -> 'a1 -> 'a1 **)

fun run_am_app_comp am_comp default_A =
  let val optRes = evalSt am_comp empty_amst in fromSome default_A optRes end

(** val am_sendReq_nonce :
    coq_Term -> coq_Plc -> coq_Plc -> coq_AppResultC coq_AM **)

fun am_sendReq_nonce t pFrom pTo =
  bind (am_newNonce gen_nonce_bits) (fn nid =>
    let val resev = am_sendReq t pFrom pTo Coq_mt [] (gen_nonce_bits :: []) in
    let val expected_et = eval t pTo (Coq_nn nid) in
    gen_appraise_AM expected_et resev end end)

(** val run_am_sendReq_nonce :
    coq_Term -> coq_Plc -> coq_Plc -> coq_AppResultC **)

fun run_am_sendReq_nonce t pFrom pTo =
  let val am_comp = am_sendReq_nonce t pFrom pTo in
  run_am_app_comp am_comp Coq_mtc_app end

(** val am_sendReq_nonce_auth :
    coq_Term -> coq_Plc -> coq_Plc -> coq_AppResultC coq_AM **)

fun am_sendReq_nonce_auth t pFrom pTo =
  bind (am_newNonce gen_nonce_bits) (fn nid =>
    let val auth_rawev = run_cvm_rawEv ssl_sig pFrom [] in
    let val auth_et = eval ssl_sig pFrom Coq_mt in
    let val resev =
      am_sendReq t pFrom pTo auth_et auth_rawev (gen_nonce_bits :: [])
    in
    let val expected_et = eval t pTo (Coq_nn nid) in
    gen_appraise_AM expected_et resev end end end end)

(** val run_am_sendReq_nonce_auth :
    coq_Term -> coq_Plc -> coq_Plc -> coq_AppResultC **)

fun run_am_sendReq_nonce_auth t pFrom pTo =
  let val am_comp = am_sendReq_nonce_auth t pFrom pTo in
  run_am_app_comp am_comp Coq_mtc_app end

(** val am_check_auth_tok :
    coq_Term -> coq_Plc -> coq_RawEv -> coq_Evidence -> coq_AppResultC coq_AM **)

fun am_check_auth_tok t fromPl auth_ev auth_et =
  bind
    (case requester_bound t fromPl auth_et of
       True => gen_appraise_AM auth_et auth_ev
     | False => ret Coq_mtc_app) ret

(** val am_serve_auth_tok_req :
    coq_Term -> coq_Plc -> coq_Plc -> coq_RawEv -> coq_Evidence -> coq_RawEv
    -> coq_RawEv coq_AM **)

fun am_serve_auth_tok_req t fromPl myPl auth_ev auth_et init_ev =
  bind (am_check_auth_tok t fromPl auth_ev auth_et) (fn v =>
    case case requester_bound t fromPl auth_et of
           True => appraise_auth_tok v
         | False => False of
      True =>
      (case privPolicy fromPl t of
         True => ret (run_cvm_rawEv t myPl init_ev)
       | False => failm)
    | False => failm)

(** val run_am_serve_auth_tok_req :
    coq_Term -> coq_Plc -> coq_Plc -> coq_RawEv -> coq_Evidence -> coq_RawEv
    -> coq_RawEv **)

fun run_am_serve_auth_tok_req t fromPl myPl auth_ev auth_et init_ev =
  run_am_app_comp
    (am_serve_auth_tok_req t fromPl myPl auth_ev auth_et init_ev) []
